#!/usr/bin/env python3


import sys
import os
import argparse
import asyncio
import logging
from pathlib import Path
from collections import defaultdict

import uvloop

from suzieq.poller.nodes import init_hosts, init_files
from suzieq.poller.services import init_services

from suzieq.poller.writer import init_output_workers, run_output_worker
from suzieq.utils import load_sq_config


def validate_parquet_args(cfg, output_args, logger):
    """Validate user arguments for parquet output"""

    if not cfg.get("data-directory", None):
        output_dir = "/tmp/suzieq/parquet-out/"
        logger.warning(
            "No output directory for parquet specified, using" "/tmp/suzieq/parquet-out"
        )
    else:
        output_dir = cfg["data-directory"]

    if not os.path.exists(output_dir):
        os.makedirs(output_dir)

    if not os.path.isdir(output_dir):
        logger.error(
            "Output directory {} is not a directory".format(output_dir))
        print("Output directory {} is not a directory".format(output_dir))
        sys.exit(1)

    logger.info("Parquet outputs will be under {}".format(output_dir))
    output_args.update({"output_dir": output_dir})

    return


def init_logger():
    """Initialize the logger"""

    # this needs to be suzieq.poller, so that it is the root of all the other pollers
    logger = logging.getLogger('suzieq.poller')
    logger.setLevel(cfg.get("logging-level", "WARNING").upper())
    fh = logging.FileHandler(cfg.get("log-file", "/tmp/sq-poller.log"))
    formatter = logging.Formatter(
        "%(asctime)s - %(name)s - %(levelname)s " "- %(message)s"
    )
    fh.setFormatter(formatter)

    # set root logger level, so that we set asyncssh log level
    #  asynchssh sets it's level to the root level
    root = logging.getLogger()
    root.setLevel(cfg.get("logging-level", "WARNING").upper())
    root.addHandler(fh)

    logger.warning(f"log level {logging.getLevelName(logger.level)}")

    return logger


async def start_poller(userargs, cfg):

    logger = init_logger()

    if not os.path.exists(cfg["service-directory"]):
        logger.error(
            "Service directory {} is not a directory".format(
                cfg['service-directory'])
        )
        print("Service directory {} is not a directory".format(
            cfg['service-directory']))
        sys.exit(1)

    if not cfg.get("schema-directory", None):
        schema_dir = "{}/{}".format(userargs.service_dir, "schema")
    else:
        schema_dir = cfg["schema-directory"]

    output_args = {}

    if "parquet" in userargs.outputs:
        validate_parquet_args(cfg, output_args, logger)

    if userargs.run_once:
        userargs.outputs = ["gather"]
        output_args['output_dir'] = userargs.output_dir

    outputs = init_output_workers(userargs.outputs, output_args)

    queue = asyncio.Queue()

    logger.info("Initializing hosts and services")
    tasks = []
    if userargs.datadir:
        tasks.append(init_files(userargs.datadir))
    else:
        tasks.append(init_hosts(userargs.devices_file,
                                userargs.ansible_file,
                                userargs.namespace))

    tasks.append(init_services(cfg["service-directory"], schema_dir, queue,
                               userargs.run_once or "forever"))

    nodes, svcs = await asyncio.gather(*tasks)

    if not nodes or not svcs:
        # Logging should've been done by init_nodes/services for details
        print('Termminating because no nodes or services found')
        sys.exit(0)

    node_callq = defaultdict(lambda: defaultdict(dict))

    node_callq.update({x: {'hostname': nodes[x].hostname,
                           'postq': nodes[x].post_commands}
                       for x in nodes})

    for svc in svcs:
        svc.set_nodes(node_callq)

    logger.info("Suzieq Started")

    if userargs.service_only:
        svclist = userargs.service_only.split(",")
    else:
        svclist = [svc.name for svc in svcs]

    working_svcs = [svc for svc in svcs if svc.name in svclist]
    if len(working_svcs) < 1:
        print(
            f"No correct services specified. Should have been one of {[svc.name for svc in svcs]}")
        sys.exit(1)

    try:
        # The logic below of handling the writer worker task separately is to ensure
        # we can terminate properly when all the other tasks have finished as in the
        # case of using file input instead of SSH
        tasks = [svc.run() for svc in working_svcs]
        tasks += [nodes[node].run() for node in nodes]
        writer_task = run_output_worker(queue, outputs)
        tasks.append(writer_task)

        while tasks:
            done, pending = await asyncio.wait(
                tasks, return_when=asyncio.FIRST_COMPLETED)
            taskobj = next(iter(pending))
            if taskobj._coro == writer_task:
                return
            tasks = list(pending)
        return

    except KeyboardInterrupt:
        logger.info("Received keyboard interrupt. Terminating")
        sys.exit(0)


if __name__ == "__main__":

    homedir = str(Path.home())
    supported_outputs = ["parquet"]

    parser = argparse.ArgumentParser()
    requiredgrp = parser.add_mutually_exclusive_group(required=True)
    requiredgrp.add_argument(
        "-D",
        "--devices-file",
        type=str,
        help="File with URL of devices to gather data from",
    )
    requiredgrp.add_argument(
        "-i",
        "--ansible-file",
        type=str,
        help="Ansible inventory file of devices to gather data from",
    )
    requiredgrp.add_argument(
        "-f",
        "--datadir",
        type=str,
        help="Directory where previously gathered data outputs is"
    )

    parser.add_argument(
        "-n",
        "--namespace",
        type=str, required='--ansible-file' in sys.argv or "-i" in sys.argv,
        help="Namespace to associate for the gathered data"
    )
    parser.add_argument(
        "-o",
        "--outputs",
        nargs="+",
        default=["parquet"],
        choices=supported_outputs,
        type=list,
        help="Output formats to write to: parquet. Use "
        "this option multiple times for more than one output",
    )
    parser.add_argument(
        "-s",
        "--service-only",
        type=str,
        help="Only run this comma separated list of services",
    )

    parser.add_argument(
        "-c",
        "--config",
        type=str, help="alternate config file"
    )

    parser.add_argument(
        "--run-once",
        type=str,
        choices=["gather", "process"],
        help=argparse.SUPPRESS,
    )

    parser.add_argument(
        "--output-dir",
        type=str,
        default=f'{os.path.abspath(os.curdir)}/sqpoller-output',
        help=argparse.SUPPRESS,
    )

    userargs = parser.parse_args()

    cfg = load_sq_config(config_file=userargs.config)

    uvloop.install()

    asyncio.run(start_poller(userargs, cfg))
